
# hmm-java

A Java implementation for working with Hidden Markov Models (HMMs). This project provides core algorithms like Viterbi and Forward-Backward for predicting hidden states from observed sequences and includes functionality for evaluating prediction performance.

## Table of Contents

- [What is a Hidden Markov Model?](#what-is-a-hidden-markov-model)
- [Problem Definition](#problem-definition)
- [HMM Components (Based on Sample Files)](#hmm-components-based-on-sample-files)
- [Implemented Algorithms and Features](#implemented-algorithms-and-features)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Project Structure](#project-structure)
  - [Compilation](#compilation)
  - [Running the Application](#running-the-application)
- [Input File Format](#input-file-format)
  - [Model File Format](#model-file-format)
  - [Data File Format](#data-file-format)
- [Example Execution and Output](#example-execution-and-output)

## What is a Hidden Markov Model?

A Hidden Markov Model (HMM) is a statistical model used to describe a system that is assumed to be a Markov process with unobservable (hidden) states. The outputs or observations from the system are visible, but the process's underlying states are hidden.

HMMs are powerful tools used in various applications such as speech recognition, bioinformatics (e.g., sequence alignment), natural language processing, and time series analysis.

## Problem Definition

The core problem addressed by this project is, given a Hidden Markov Model (defined by a set of hidden states, a set of observable symbols, a matrix of transition probabilities between hidden states, and a matrix of emission probabilities of symbols from each hidden state) and a sequence of observations generated by the model, to **find the most likely sequence of underlying hidden states** that produced these observations.

This project solves this problem by implementing standard HMM algorithms to read the HMM definition and the observation sequence from input files and predict the corresponding hidden states. The included sample files (`data/default.data` and `models/default.model`) represent a **synthetic example problem** designed to test the algorithms.

## HMM Components (Based on Sample Files)

Using the provided sample files (`models/default.model` and `data/default.data`) as an example:

*   **Hidden States:** The unobservable states that the system can be in. In this specific synthetic example, the primary hidden states are `St1` and `St2`. The model also includes special states `B` (Begin) and `E` (End) to handle the start and end of sequences.
*   **Observable States / Emission Symbols:** The data that we can directly observe. In this example, the observable symbols are `a`, `b`, and `c`.
*   **Transition Matrix:** Defines the probabilities of transitioning from one hidden state to another over time. This is specified in the `models/default.model` file (e.g., probability of moving from St1 to St2, or staying in St1). The probabilities from the `B` state represent the initial probabilities of starting in `St1` or `St2`.
*   **Emission Matrix:** Defines the probabilities of observing a specific symbol when the system is in a specific hidden state. This is also specified in `models/default.model` (e.g., the probability of observing 'b' when the system is in state St1).
*   **Initial State Probability:** As mentioned, this is implicitly handled by the transition probabilities from the special `B` (Begin) state to the actual hidden states (`St1`, `St2`) at the beginning of the observation sequence.

## Implemented Algorithms and Features

This project implements the following core HMM algorithms:

*   **Viterbi Algorithm:** A dynamic programming algorithm that finds the single most probable sequence of hidden states that results in a given sequence of observations.
*   **Forward-Backward Algorithm:** Calculates the marginal probability of being in a particular hidden state at a particular time step, given the sequence of observations. This is used here to find the most probable state at each individual step.
*   **Prediction Estimation:** Includes logic to build a Confusion Matrix and compute standard evaluation metrics (True Positives, False Positives, True Negatives, False Negatives, F-measure) for each hidden state, comparing the predicted sequence against the ground truth provided in the data file.

## Getting Started

Follow these steps to compile and run the HMM application.

### Prerequisites

*   Java Development Kit (JDK) installed (version 8 or higher recommended).
*   Git (optional, if you prefer cloning).

### Project Structure

Ensure your project files are organized in a structure similar to this (assuming `java-hmm` is the root directory):

```text
java-hmm/
├── data/
│   └── default.data
├── models/
│   ├── default.model
│   └── ... (other model files if any)
├── src/
│   └── hmm/                 
│       ├── algorithms/
│       │   └── Algorithms.java
│       ├── data/
│       │   ├── ExperimentData.java
│       │   ├── Model.java
│       │   ├── PredictionEstimation.java
│       │   └── TimeStateSymbolTuple.java
│       ├── estimation/
│       │   └── Estimation.java
│       └── Main.java        
└── ... (other project files like .gitignore, IDE configs, etc.)
```

### Compilation

Open a terminal or command prompt, navigate to the root directory of the project (`java-hmm/`), and run the following command to compile all Java source files:

```bash
  javac src/hmm/*/*.java src/hmm/*.java
```

This command compiles `.java` files within the `hmm` package and its subdirectories (`algorithms`, `data`, `estimation`) and places the compiled `.class` files into the default output location (often `out/production/java-hmm/` or similar, depending on your setup/IDE).

### Running the Application

Run the compiled application from the project root directory, providing the path to the model file and the data file as command-line arguments:

```bash
  java -classpath out/production/java-hmm hmm.Main models/default.model data/default.data
```

*   Replace `out/production/java-hmm` with the actual path to your compiled classes if different.
*   Replace `models/default.model` and `data/default.data` with the paths to the specific model and data files you want to process.

## Input File Format

The application expects model and data files to adhere to a specific text format.

### Model File Format

The model file (`.model`) describes the HMM parameters in the following order:

1.  `nstates`: Number of states (integer). Includes 'begin' and 'end' states.
2.  `state_name_1 state_name_2 ... state_name_nstates`: List of state names (strings), separated by spaces. 'begin' should be the first, 'end' should be the last.
3.  `alphabet_size`: Number of observable symbols (integer).
4.  `ntransitions`: Number of specified non-zero transition probabilities (integer).
5.  `ntransitions` lines, each in the format: `from_state_name to_state_name probability` (string string double).
6.  `nemissions`: Number of specified non-zero emission probabilities (integer).
7.  `nemissions` lines, each in the format: `state_name symbol probability` (string string double). Symbol should be a single lowercase letter 'a'-'z'.

**Example (`models/default.model`):**

```
4
B St1 St2 E
3
8
B St1 0.526
B St2 0.474
St1 E 0.002
St1 St1 0.969
St1 St2 0.029
St2 E 0.002
St2 St1 0.063
St2 St2 0.935
6
St1 a 0.005
St1 b 0.775
St1 c 0.220
St2 a 0.604
St2 b 0.277
St2 c 0.119
```

### Data File Format

The data file (`.data`) contains the observation sequence and the ground truth hidden states (if available for evaluation).

1.  `nsteps`: Total number of time steps/observations (integer).
2.  `nsteps` lines, each in the format: `step_number real_state_name observed_symbol` (integer string string). `step_number` is typically 0-indexed. `real_state_name` is the actual hidden state at that step (used for evaluation). `observed_symbol` is the symbol observed at that step.

**Example (`data/default.data` excerpt):**

```
400
0	St1	b
1	St1	b
2	St1	b
...
399	St2	a
```
(Note: The full `default.data` contains 400 lines of observations).

## Example Execution and Output

When running the application with the provided `models/default.model` and `data/default.data` files, you should see output similar to this:

```text
Viterbi algorithm state prediction estimations:
State St1 => True Positives=212, False Positives=7, True Negatives=175, False Negatives=6, f-measure=0.9703
State St2 => True Positives=175, False Positives=6, True Negatives=212, False Negatives=7, f-measure=0.9642


Forward-backward algorithm state prediction estimations:
State St1 => True Positives=212, False Positives=7, True Negatives=175, False Negatives=6, f-measure=0.9703
State St2 => True Positives=175, False Positives=6, True Negatives=212, False Negatives=7, f-measure=0.9642

```
This output shows the performance metrics (True Positives, False Positives, etc., and F-measure) for predicting states `St1` and `St2` using both the Viterbi and Forward-Backward algorithms, evaluated against the ground truth in `default.data`.



